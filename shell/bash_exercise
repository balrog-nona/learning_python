1. Run the program "test.sh" and discard any output (standard and error) of that script.

bash ./test.sh >> /dev/null

2. Copy a directory tree (with files) from /opt/test/ to your home directory using tar.

tar -cvf test-08-07-19.tar ~/Downloads/opt/test

3. Rename all .htm files in /tmp/test/ (but not subdirectories), so that they have .html extension instead of .htm. Ignore hidden files.

rename .htm .html *.html - neumela jsem to zadat s mistem, kde se ma prikaz provest
rename .hmt .html /tmp/test/* - rename co zaco kde

4. Print contents of all files in /tmp/test/ (but not subdirectories), including hidden files. Ensure that the filesystem object is a regular file.

for file in /tmp/test/* /tmp/test/.* ; do cat $file ; done
find /tmp/test/ -maxdepth 1 -type f -exec cat {} \;
oboje udelalo to stejne, akorat v jinem poradi

5. List all files (their full paths) in /tmp/test/ and subdirectories, that contain the left bracket "["

grep -r -l ‘\[‘ /tmp/test/  - toto dava jen relativni cestu! v zadani je full path
grep -R \\[ /tmp/test/ | cut -d: -f1 | xargs -I{} realpath {}   

6. You have a file "/tmp/test/IMPORTANT" and a new version of it in your home directory named "IMPORTANT.new". Write a sequence of commands
	that would replace the old version of the file with the new one, and keep the backup named "/tmp/test/IMPORTANT.backup". There must
	be no race condition (time slice when the file is not there, or when there is just part of it).

cat IMPORTANT > IMPORTANT.backup && cat ~/IMPORTANT.new > IMPORTANT  - tady mi uplne chybi cesta!
cat /tmp/test/IMPORTANT > /tmp/test/IMPORTANT.backup && cat ~/IMPORTANT.new > /tmp/test/IMPORTANT
Misovo:
ln /tmp/test/IMPORTANT /tmp/test/IMPORTANT.backup
ln -f ~/IMPORTANT.new /tmp/test/IMPORTANT

7. Transfer directory "/tmp/test/" (and everything below) to a machine named "orion" to directory "/var/tmp/test". Use ssh.

ssh orion mv /tmp/test/ /var/tmp/test

8. Force apache to reload its configuration by sending a signal to it; "apache.pid" file is located in "/var/apache/".

sudo /var/apache/ reload

9. In "/tmp/test" and subdirs there are files with ".dat" extension (among others). The files contain numbers separated by 0x0A (LF).
	Print the smallest number from each of the file.

for file in /tmp/test/*.dat /tmp/test/*/*.dat ; do echo -e $(sed ‘s/0x/\\x/g’ $file) | sort -n | head -1 ; done

10. There is a filesystem mounted on /usr containing new version of binaries. Create a hard link "/bin/perl" for file "/usr/bin/perl".

ln /usr/bin/perl /bin/perl

11. Set ownership to "root" group "sys" for directory "/tmp/test" and everything below.

sudo chown :sys /tmp/test/

12. Set rights for "/tmp/test/" tree (both files and directories), so that the owner can read and write files (but not execute), group can only
	read, and others are denied access altogether. The directories must be accessible for owner and group only.

chmod -R u=rwX,g=rX,o=- /tmp/*
Misovo: chmod -R u=rwX,g=rX,o= /tmp/test/

13. Write a shell glob matching all files (and other objects) in the current directory, including hidden files, but not matching the "." or ".."

* | !(.|..) - tohle absolutne nefungovalo s zadnym prikazem
.[^.]* *  - . ale ne dalsi . a cokoli + cokoli. funguje s kazdym prikazem, kde lze pouzit glob

14. Set permissions for binary "/usr/local/bin/my_program", so that only "root" and members of the "adm" group can execute it; and when
	executed, the program runs under "daemon" UID.

sudo setfacl -m u:root:r-x,g:adm:r-x /usr/local/bin/my_program && setuid $daemon /usr/local/bin/my_program

15. Set permissions for "/tmp/test/", so that root cannot delete files in this directory.

setfacl -m u:root:r-x /tmp/test

16. List lines in file "/tmp/test/pkgs" that start with SUNW then a hexadecimal number followed by a space, and end with an asterisk.

egrep ‘^SUNW[‘[:xdigit:]’]{1,}[‘[:space:]’].*\*$’ /tmp/test/pkgs
egrep ‘^SUNW[‘[:xdigit:]’]+[‘[:space:]’].*\*$’ /tmp/test/pkgs
option -c zmeni vystupn grepu - misto radku vrati pocet!

17. Copy file "/tmp/test/pkgs" to your home directory, so that the new name is pkgs-YYYYMMDD (where YYYYMMDD is the current date).

cp /tmp/test/pkgs ~/pkgs-$(date +’%Y%m%d’)
cp -p /tmp/test/pkgs ~/pkgs-`date '+%Y%m%d'` - option -p zachova i vsechny dalsi atributy souboru 

18. List user names from /etc/passwd that have UID > 500

while IFS=: read login pwd uid gid full home shell; do if (( $iud > 500 )); then echo $login; fi; done < /etc/passwd
while IFS=: read username x uid x; do if [ $uid -gt 500 ]; then echo $username; fi; done < /etc/passwd
awk -F: ‘$3 > 500’ < /etc/passwd | awk -F: '{print $1}’


K subshellu:
cat `echo textak` - prikaz mezi `` se provede jako prvni a jeho vysledek jde do cat, tato konstrukce muze mit jen 2 roviny
cat $(echo textak) - prikaz v $() se provede jako prvni a jeho vysledek jde do cat, ale zde je mozna spousta rovin - dalsi $() muze
byt v te prvni zavorce













